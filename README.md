# The Rust Programming Language Second Edition

https://rinthel.github.io/rust-lang-book-ko/

## Ownership
러스트의 가장 유니크한 특성, 러스트가 가비지 콜렉터 없이 메모리 안정성 보장을 하게 해준다

러스트는 제3의 접근법을 이용한다
메모리는 컴파일 타임에 컴파일러가 체크할 규칙들로 구성된 소유권 시스템을 통해 관리된다
소유권 기능들의 어떤 것도 런타임 비용이 발생하지 않는다

### 스택과 힙

- Stack: LIFO(Last In First Out) 구조, 빠르지만 크기가 컴파일 타임에 결정된다
  - 데이터를 추가하는 것 스택에 푸시하기(pushing on to the stack)
  - 데이터를 제거하는 것 스택에서 팝하기(popping off the stack)
- Heap: 느리지만 크기가 런타임에 결정된다

스택은 데이터에 접근하는 방식 덕택에 빠르다
새로운 데이터를 넣어두기 위한 공간 혹은 데이터를 가져올 공간을 검색할 필요가 전혀 없는데 바로 그 공간이 항상 스택의 꼭대기이기 때문이다
스택에 담긴 모든 데이터가 결정되어 있는 고정된 크기를 갖고 있어야 한다

컴파일 타임에 크기가 결정되어 있지 않거나 크기가 변경될 수 있는 데이터를 위해서는, 힙에 데이터를 저장할 수 있다
데이터를 힙에 넣을때, 먼저 저장할 공간이 있는지 묻는다
운영체제가 충분히 커다란 힙 안의 빈 어떤 지점을 찾아서 이 곳을 사용중이라고 표시하고, 해당 지점의 포인터를 우리에게 돌려준다
이 절차를 힙 공간 할당하기(allocating on the heap)라고 부르고, 종종 그냥 할당(allocating)으로 줄여 부른다
포인터는 결정되어 있는 고정된 크기의 값이므로, 스택에 포인터를 저장할 수 있지만, 실제 데이터를 사용하고자 할 때는 포인터를 따라가야 한다

힙에 저장된 데이터에 접근하는 것은 스택에 저장된 데이터에 접근하는 것보다 느린데, 그이유는 포인터가 가리킨 곳을 따라가야 하기 때문이다
프로세서는 (힙에 있는 데이터와 같이) 멀리 떨어져 있는 데이터들 보다는 (스택에 있는 것과 같이) 붙어있는 데이터들에 대한 작업을 하면 더 빨라진다
힙으로부터 큰 공간을 할당받는것 또한 시간이 걸릴 수 있다

소유권과 관계된 문제들
- 코드의 어느 부분이 힙의 어떤 데이터를 사용하는지 추적하는 것
- 힙의 중복된 데이터의 양을 최소화하는 것
- 힙 내에 사용하지 않는 데이터를 제거하여 공간이 모자라지 않게 하는 것

힙 데이터를 관리하는 것이 곧 소유권의 존재 이유이다

### 소유권 규칙
- 러스트의 각각의 값은 해당값의 소유자(owner)라고 불리우는 변수를 갖고 있다
- 한번에 딱 하나의 오너만 존재할 수 있다
- 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped)

### String 타입

String Literal로 부터 `from` 이라는 함수를 이용해서 `String`을 만들 수 있다

```rust
let s = String::from("hello");
```

더블 콜론(`::`)은 `String` 타입 아래의 `from` 함수를 특정지을 수 있도록 해주는 네임스페이스 연산자이다

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str()은 해당 스트링 리터럴을 스트링에 붙여준다
println!("{}", s); // 이 부분이 `hello, world!`를 출력한다
```

### 메모리와 할당

러스트는 메모리는 변수가 소속되어 있는 스코프 밖으로 벗어나는 순간 자동으로 반납된다

```rust
{
    let s = String::from("hello"); // s는 이 지점부터 유효하다
    // s를 사용한다
} // 이 스코프는 끝났고, s는 더이상 유효하지 않다
```

### 가변 참조자(Mutable References)

- 가변 참조자의 딱 한가지 큰 제한
  - 특정한 스코프 내에 특정한 데이터 조각에 대한 가변 참조자를 딱 하나만 만들 수 있다

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;
```

#### 데이터 레이스(data race)

1. 두 개 이상의 포인터가 동시에 같은 데이터에 접근한다
2. 그 중 적어도 하나의 포인터가 데이터를 쓴다
3. 데이터에 접근하는데 동기화를 하는 어떠한 메커니즘도 없다

러스트는 이러한 데이터 레이스를 방지하기 위해 컴파일 타임에 가변 참조자를 사용하는 규칙을 강제한다  

불변 참조자를 가지고 있을 동안에도 가변 참조자를 만들 수 없음

#### 댕글링 포인터(dangling pointer)

댕글링 포인터란 어떤 메모리를 가리키는 포인터를 보존하는 동안,  
그 메모리를 해제함으로써 다른 개체에게 사용하도록 줘버렸을 지도 모를 메모리를 참조하고 있는 포인터 

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

해결법 `String`을 직접 반환

```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```

### 슬라이스

#### 스트링 슬라이스

`String`의 참조자 대신 스트링 슬라이스를 갖도록 정의하는 것은 API를 어떠한 기능적인 손실 없이도 더 일반적이고 유용하게 해준다

소유권, 빌림, 그리고 슬라이스의 개념은 러스트 프로그램의 메모리 안정성을 컴파일 타임에 보장하는 것이다
러스트 언어는 다른 시스템 프로그래밍 언어와 같이 메모리 사용에 대한 제어권을 주지만, 데이터의 소유자가 스코프 밖으로 벗어났을 때  
소유자가 자동적으로 데이터를 버리도록 하는 것은 이러한 제어를 위해 추가적인 코드 작성이나 디버깅을 하지 않아도 된다는 뜻이다